#!/usr/bin/env python3

import os
import json
import asyncio
import logging
import requests
import datetime
import signal
import fcntl
import functools
import traceback
from logging.handlers import TimedRotatingFileHandler
from pytz import utc
from binance import AsyncClient, BinanceSocketManager, BinanceAPIException

# ============== ÈÖçÁΩÆÂå∫Âüü ==============
BASE_URL = 'https://fapi.binance.com'
BINANCE_API_KEY = 'AbaDJU8Q9puMgEbnLaZgNusgImwywULFwjIsWMv1ceZyxnSXLtlEWbNHrYcDerSs'
BINANCE_API_SECRET = 'IqLWduWAJzgCUzgtus65Hx2MP2rFSJRg1tR3g06ngmUqv0spArMuBhb38HR4slvM'

# Á≠ñÁï•ÂèÇÊï∞
ENTITY_RATIO_THRESHOLD = 0.25
UPPER_SHADOW_RATIO_THRESHOLD = 0.65
LOWER_SHADOW_RATIO_THRESHOLD = 0.2
INTERVALS = ['1h', '4h', '1d', '1w']
CUSTOM_SYMBOLS = ["ETHUSDT", "SOLUSDT", "ADAUSDT", "LINKUSDT", "XRPUSDT"]
INITIAL_INVESTMENT = 2
MAX_ALLOWED_LEVERAGE = 20
MAINTENANCE_MARGIN_RATE = {
    "BTCUSDT": 0.004,
    "DEFAULT": 0.01
}

# TelegramÈÄöÁü•ÈÖçÁΩÆ
BOT_TOKEN = "6360770475:AAHfey7ZNTW9fmdABhrG-Aa6ZwZMWhaPPlU"
CHAT_ID = "-1002286585218"
# Ë∑ØÂæÑÈÖçÁΩÆ
DATA_DIR = '/autotraderbot/data'
LOG_DIR = '/autotraderbot/log'
ORDERS_FILE = os.path.join(DATA_DIR, 'sheji_orders.json')
PROCESSED_SIGNALS_FILE = os.path.join(DATA_DIR, 'sheji_signals.txt')
SHEJI_LOG_FILE = os.path.join(LOG_DIR, 'sheji.log')
HEARTBEAT_FILE = os.path.join(DATA_DIR, 'sheji_heartbeat.txt')
HEARTBEAT_INTERVAL = 300  # ÂøÉË∑≥Èó¥ÈöîÔºàÁßíÔºâ

# ============== Êó•ÂøóÈÖçÁΩÆ ==============
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(LOG_DIR, exist_ok=True)

class LockedTimedRotatingFileHandler(TimedRotatingFileHandler):
    def __init__(self, filename, when='midnight', interval=1, backupCount=2, encoding=None, delay=False, utc=False):
        super().__init__(filename, when, interval, backupCount, encoding, delay, utc)
    
    def emit(self, record):
        try:
            with open(self.baseFilename, 'a') as f:
                fcntl.flock(f.fileno(), fcntl.LOCK_EX)
                super().emit(record)
                fcntl.flock(f.fileno(), fcntl.LOCK_UN)
        except Exception:
            self.handleError(record)

def initialize_logger():
    logger = logging.getLogger('SHEJI_TRADER')
    if logger.handlers:
        return logger
    
    logger.setLevel(logging.DEBUG)
    logger.propagate = False
    
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s'
    )
    
    file_handler = LockedTimedRotatingFileHandler(
        filename=SHEJI_LOG_FILE,
        when='midnight',
        interval=1,
        backupCount=2,
        encoding='utf-8',
        utc=True
    )
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)
    
    return logger

logger = initialize_logger()

async def update_heartbeat():
    try:
        with open(HEARTBEAT_FILE, 'w', encoding='utf-8') as f:
            f.write(datetime.datetime.now(utc).isoformat())
    except Exception as e:
        logger.error(f"Êõ¥Êñ∞ÂøÉË∑≥Êñá‰ª∂Â§±Ë¥•: {str(e)}", exc_info=True)

class ShejiTradingSystem:
    def __init__(self):
        self.client = None
        self.active_orders = {}
        self.processed_signals = set()
        self.processed_klines = {}
        self.running = True
        self.symbols_info = {}
        self.is_hedge_mode = None
        self.last_heartbeat = 0
        self._shutdown_event = asyncio.Event()
        logger.debug("‰∫§ÊòìÁ≥ªÁªüÂÆû‰æãÂàùÂßãÂåñÂÆåÊàê")

    def _round_to_precision(self, value: float, precision: int) -> float:
        return round(value, precision)

    async def initialize(self):
        try:
            logger.info("ÂºÄÂßãÂàùÂßãÂåñ Binance ÂÆ¢Êà∑Á´Ø")
            self.client = await AsyncClient.create(
                BINANCE_API_KEY,
                BINANCE_API_SECRET,
                tld='com'
            )
            await self._load_state()
            
            position_mode = await self.client.futures_get_position_mode()
            self.is_hedge_mode = position_mode['dualSidePosition']
            logger.info(f"Ë¥¶Êà∑‰ªì‰ΩçÊ®°Âºè: {'ÂØπÂÜ≤Ê®°Âºè' if self.is_hedge_mode else 'ÂçïÂêëÊ®°Âºè'}")
            
            exchange_info = await self.client.futures_exchange_info()
            for symbol_info in exchange_info['symbols']:
                symbol = symbol_info['symbol']
                if symbol not in CUSTOM_SYMBOLS:
                    continue
                self.symbols_info[symbol] = {'step_size': 0.001, 'price_precision': 2}
                for f in symbol_info['filters']:
                    if f['filterType'] == 'LOT_SIZE':
                        self.symbols_info[symbol]['step_size'] = float(f['stepSize'])
                    elif f['filterType'] == 'PRICE_FILTER':
                        tick_size = float(f['tickSize'])
                        if tick_size < 1e-4:
                            self.symbols_info[symbol]['price_precision'] = 5
                        elif tick_size < 1e-3:
                            self.symbols_info[symbol]['price_precision'] = 4
                        elif tick_size < 1e-2:
                            self.symbols_info[symbol]['price_precision'] = 3
                        else:
                            self.symbols_info[symbol]['price_precision'] = 2
            
            logger.info("‰∫§ÊòìÊâÄËøûÊé•ÂàùÂßãÂåñÊàêÂäü")
            logger.debug(f"Symbols info: {json.dumps(self.symbols_info, indent=2)}")
        except Exception as e:
            logger.error(f"ÂàùÂßãÂåñÂ§±Ë¥•: {str(e)}", exc_info=True)
            await self._send_error_alert(e, "ÂàùÂßãÂåñÈò∂ÊÆµ")
            raise

    async def _load_state(self):
        try:
            if os.path.exists(ORDERS_FILE):
                with open(ORDERS_FILE, 'r', encoding='utf-8') as f:
                    orders = json.load(f)
                    valid_orders = {}
                    for order_id, order_info in orders.items():
                        if order_info['status'] in ['FILLED', 'CANCELED']:
                            continue
                        try:
                            res = await self.client.futures_get_order(
                                symbol=order_info['symbol'],
                                orderId=order_id
                            )
                            if res['status'] not in ['FILLED', 'CANCELED']:
                                valid_orders[order_id] = order_info
                                logger.debug(f"ËÆ¢ÂçïÈ™åËØÅÈÄöËøá | {order_info['symbol']} | ID: {order_id}")
                            else:
                                logger.info(f"ËøáÊª§Â∑≤ÁªìÊùüËÆ¢Âçï | {order_info['symbol']} | ID: {order_id} | Áä∂ÊÄÅ: {res['status']}")
                        except BinanceAPIException as e:
                            if e.code == -2013:
                                logger.info(f"ËÆ¢Âçï‰∏çÂ≠òÂú®ÔºåË∑≥ËøáÂä†ËΩΩ | ID: {order_id}")
                            else:
                                logger.error(f"ËÆ¢ÂçïÈ™åËØÅÂ§±Ë¥• | ID: {order_id} | ÈîôËØØ: {e.message}")
                    self.active_orders = valid_orders
                    logger.info(f"ÊúâÊïàËÆ¢ÂçïÂä†ËΩΩÂÆåÊàê | Êï∞Èáè: {len(self.active_orders)}")

            if os.path.exists(PROCESSED_SIGNALS_FILE):
                with open(PROCESSED_SIGNALS_FILE, 'r', encoding='utf-8') as f:
                    self.processed_signals = set(line.strip() for line in f)
                logger.debug(f"Â∑≤Âä†ËΩΩÂéÜÂè≤‰ø°Âè∑ {len(self.processed_signals)} Êù°")
        except Exception as e:
            logger.error(f"Áä∂ÊÄÅÂä†ËΩΩÂ§±Ë¥•: {str(e)}", exc_info=True)

    async def _save_state(self):
        try:
            with open(ORDERS_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.active_orders, f, indent=2, ensure_ascii=False)
                logger.debug("ËÆ¢ÂçïËÆ∞ÂΩï‰øùÂ≠òÊàêÂäü")

            with open(PROCESSED_SIGNALS_FILE, 'w', encoding='utf-8') as f:
                f.write("\n".join(self.processed_signals))
                logger.debug("‰ø°Âè∑ËÆ∞ÂΩï‰øùÂ≠òÊàêÂäü")
        except Exception as e:
            logger.error(f"Áä∂ÊÄÅ‰øùÂ≠òÂ§±Ë¥•: {str(e)}", exc_info=True)

    async def _send_notification(self, message: str):
        try:
            logger.debug(f"ÂèëÈÄÅÈÄöÁü• | ÂÜÖÂÆπ: {message[:100]}...")
            response = requests.post(
                f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage",
                json={
                    "chat_id": CHAT_ID,
                    "text": message
                },
                timeout=10
            )
            if response.ok:
                logger.debug(f"ÈÄöÁü•ÂèëÈÄÅÊàêÂäü | ÂìçÂ∫î: {response.text}")
            else:
                logger.error(f"TelegramÈÄöÁü•Â§±Ë¥• | Áä∂ÊÄÅÁ†Å: {response.status_code} | ÂìçÂ∫î: {response.text}")
        except Exception as e:
            logger.error(f"ÈÄöÁü•ÂèëÈÄÅÂ§±Ë¥• | ÈîôËØØ: {str(e)}", exc_info=True)

    async def _send_error_alert(self, error: Exception, context: str = ""):
        tb = traceback.format_exc()
        error_time = datetime.datetime.now(utc).strftime('%Y-%m-%d %H:%M:%S')
        alert_msg = (
            "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
            "üö® Á≥ªÁªüÈîôËØØ\n"
            f"‚ñ´Ô∏è Êó∂Èó¥: {error_time}\n"
            f"‚ñ´Ô∏è Á±ªÂûã: {error.__class__.__name__}\n"
            f"‚ñ´Ô∏è ËØ¶ÊÉÖ: {str(error)[:200]}\n"
            f"‚ñ´Ô∏è ‰∏ä‰∏ãÊñá: {context}\n"
            f"‚ñ´Ô∏è ËøΩË∏™:\n{tb}"
        )
        await self._send_notification(alert_msg)

    async def _get_current_price(self, symbol: str) -> float:
        try:
            ticker = await self.client.futures_symbol_ticker(symbol=symbol)
            return float(ticker['price'])
        except Exception as e:
            logger.error(f"Ëé∑ÂèñÂΩìÂâç‰ª∑Ê†ºÂ§±Ë¥• | {symbol} | ÈîôËØØ: {str(e)}")
            return None

    async def _get_klines(self, symbol: str, interval: str) -> list:
        try:
            klines = await self.client.futures_klines(
                symbol=symbol,
                interval=interval,
                limit=2
            )
            return klines
        except BinanceAPIException as e:
            logger.error(f"KÁ∫øËé∑ÂèñÂ§±Ë¥• | {symbol} | {interval} | {e}")
            await self._send_error_alert(e, f"Ëé∑ÂèñKÁ∫ø {symbol} {interval}")
            return None

    def _analyze_kline(self, prev_kline, curr_kline, symbol: str) -> dict:
        try:
            # ‰ΩøÁî®prev_klineÔºàÂ∑≤Èó≠ÂêàÁöÑKÁ∫øÔºâËøõË°åÂàÜÊûê
            current_time = datetime.datetime.now(utc).timestamp()
            kline_close_time = prev_kline[6] / 1000  # ‰ΩøÁî®Ââç‰∏ÄKÁ∫øÁöÑÈó≠ÂêàÊó∂Èó¥
            
            if current_time < kline_close_time:
                logger.debug(f"ÂøΩÁï•Êú™Èó≠ÂêàKÁ∫ø | {symbol} | Èó≠ÂêàÊó∂Èó¥: {datetime.datetime.fromtimestamp(kline_close_time)}")
                return None

            prev_open = float(prev_kline[1])
            prev_close = float(prev_kline[4])
            prev_high = float(prev_kline[2])
            prev_low = float(prev_kline[3])

            entity_size = abs(prev_close - prev_open)
            total_range = prev_high - prev_low
            
            if total_range < 1e-8:
                return None

            entity_ratio = entity_size / total_range
            upper_ratio = (prev_high - max(prev_open, prev_close)) / total_range
            lower_ratio = (min(prev_open, prev_close) - prev_low) / total_range

            if (entity_ratio < ENTITY_RATIO_THRESHOLD and
                upper_ratio > UPPER_SHADOW_RATIO_THRESHOLD and
                lower_ratio < LOWER_SHADOW_RATIO_THRESHOLD and
                prev_close < curr_kline[2]):  # ‰ΩøÁî®ÂΩìÂâçKÁ∫øÁöÑÈ´òÁÇπËøõË°åÊØîËæÉ
                return self._calculate_trade_params(
                    open_price=prev_close,
                    low_price=prev_low,
                    high_price=prev_high,
                    symbol=symbol
                )
            return None
        except Exception as e:
            logger.error(f"KÁ∫øÂàÜÊûêÂºÇÂ∏∏ | {symbol} | {str(e)}", exc_info=True)
            asyncio.create_task(self._send_error_alert(e, f"KÁ∫øÂàÜÊûê {symbol}"))
            return None

    def _calculate_trade_params(self, **kwargs) -> dict:
        try:
            symbol_info = self.symbols_info.get(kwargs['symbol'], {'price_precision': 4})
            price_precision = symbol_info['price_precision']
            step_size = symbol_info.get('step_size', 0.001)

            entry = self._round_to_precision(kwargs['open_price'], price_precision)
            price_diff = kwargs['high_price'] - kwargs['low_price']
            sl = self._round_to_precision(
                kwargs['low_price'] - price_diff * 0.272,
                price_precision
            )
            min_price_diff = 10 ** (-price_precision)
            
            if sl >= entry:
                sl = entry - min_price_diff
                logger.warning(f"Âº∫Âà∂Ë∞ÉÊï¥Ê≠¢Êçü‰ª∑Ëá≥ÊúâÊïàÂÄº: {sl}ÔºàÂéüËÆ°ÁÆóÂÄº: {kwargs['low_price'] - price_diff*0.272}Ôºâ")

            tp = self._round_to_precision(
                kwargs['high_price'] - price_diff * 0.382,
                price_precision
            )

            if entry == 0:
                return None

            risk_pct = abs((entry - sl) / entry * 100)
            if risk_pct == 0:
                return None

            reward_pct = abs((tp - entry) / entry * 100)
            rr_ratio = round(reward_pct / risk_pct, 2)

            margin_rate = MAINTENANCE_MARGIN_RATE.get(kwargs['symbol'], MAINTENANCE_MARGIN_RATE["DEFAULT"])
            leverage_calc = int(1 / (margin_rate + (risk_pct / 100)))
            leverage = min(leverage_calc, MAX_ALLOWED_LEVERAGE)

            quantity = (INITIAL_INVESTMENT * leverage_calc) / entry
            quantity = round((quantity // step_size) * step_size, 8)

            required_margin = (quantity * entry) / leverage
            if required_margin > INITIAL_INVESTMENT:
                logger.warning(f"ÊâÄÈúÄ‰øùËØÅÈáë‰∏çË∂≥: {required_margin:.2f} USDT")

            return {
                'symbol': kwargs['symbol'],
                'side': 'BUY',
                'price': entry,
                'quantity': quantity,
                'stop_loss': sl,
                'take_profit': tp,
                'leverage': leverage,
                'risk_pct': round(risk_pct, 2),
                'reward_pct': round(reward_pct, 2),
                'risk_reward': rr_ratio,
                'interval': kwargs.get('interval', 'N/A')
            }
        except Exception as e:
            logger.error(f"ÂèÇÊï∞ËÆ°ÁÆóÂ§±Ë¥• | {kwargs.get('symbol')} | {str(e)}", exc_info=True)
            asyncio.create_task(self._send_error_alert(e, f"ÂèÇÊï∞ËÆ°ÁÆó {kwargs.get('symbol')}"))
            return None

    async def _place_order(self, signal: dict):
        if not signal:
            return
        try:
            logger.debug(f"ÂºÄÂßãÊåÇÂçï | {signal['symbol']} | ‰ª∑Ê†º: {signal['price']}")
            await self.client.futures_change_leverage(
                symbol=signal['symbol'],
                leverage=signal['leverage']
            )
            order_params = {
                'symbol': signal['symbol'],
                'side': signal['side'],
                'type': 'LIMIT',
                'price': str(signal['price']),
                'quantity': str(signal['quantity']),
                'timeInForce': 'GTC'
            }
            if self.is_hedge_mode:
                order_params['positionSide'] = 'LONG' if signal['side'] == 'BUY' else 'SHORT'

            order = await self.client.futures_create_order(**order_params)
            self.active_orders[order['orderId']] = {
                **signal,
                'status': 'NEW',
                'orderId': order['orderId'],
                'timestamp': datetime.datetime.now(utc).isoformat()
            }
            await self._save_state()

            msg = (
                "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
                f"üéØ Êñ∞‰∫§Êòì‰ø°Âè∑ {signal['symbol']}\n"
                f"‚ñ´Ô∏è Âë®Êúü: {signal['interval']}\n"
                f"üè∑ ÂÖ•Âú∫‰ª∑: {signal['price']:.4f}\n"
                f"üõë Ê≠¢Êçü: {signal['stop_loss']:.4f} (-{signal['risk_pct']}%)\n"
                f"üéØ Ê≠¢Áõà: {signal['take_profit']:.4f} (+{signal['reward_pct']}%)\n"
                f"‚öñÔ∏è È£éÈô©ÊØî: 1:{signal['risk_reward']}\n"
                f"üìà Êù†ÊùÜ: {signal['leverage']}x\n"
                f"üì¶ Êï∞Èáè: {signal['quantity']:.6f}"
            )
            await self._send_notification(msg)
            logger.info(f"ÊåÇÂçïÊàêÂäü | {signal['symbol']} | ËÆ¢ÂçïID: {order['orderId']}")
        except BinanceAPIException as e:
            error_msg = f"ÊåÇÂçïÂ§±Ë¥• | {signal['symbol']} | ÈîôËØØ: {e.message}"
            logger.error(error_msg)
            await self._send_notification(
                "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
                f"‚ùå {signal['symbol']} ÊåÇÂçïÂ§±Ë¥•: {e.message}"
            )
        except Exception as e:
            error_msg = f"ÊåÇÂçïÂºÇÂ∏∏ | {signal['symbol']} | ÈîôËØØ: {str(e)}"
            logger.error(error_msg, exc_info=True)
            await self._send_notification(
                "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
                f"‚ö†Ô∏è {signal['symbol']} ÊåÇÂçïÂºÇÂ∏∏: {str(e)}"
            )

    async def _monitor_orders(self):
        logger.info("ÂêØÂä®ËÆ¢ÂçïÁõëÊéßÂæ™ÁéØ")
        try:
            while not self._shutdown_event.is_set():
                try:
                    for order_id, order_info in list(self.active_orders.items()):
                        try:
                            res = await self.client.futures_get_order(
                                symbol=order_info['symbol'],
                                orderId=order_id
                            )
                            new_status = res['status']
                            old_status = order_info.get('status', 'UNKNOWN')
                            
                            if new_status != old_status:
                                self.active_orders[order_id]['status'] = new_status
                                await self._save_state()
                                
                                logger.info(
                                    f"ËÆ¢ÂçïÁä∂ÊÄÅÂêåÊ≠• | {order_info['symbol']} | ID: {order_id} | "
                                    f"Áä∂ÊÄÅÂèòÊõ¥: {old_status} ‚Üí {new_status}"
                                )
                                
                                if new_status == 'CANCELED' and order_info.get('type') in ['STOP_LOSS', 'TAKE_PROFIT']:
                                    msg = (
                                        "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
                                        f"üë§ ËÆ¢ÂçïÂ∑≤Ë¢´ÊâãÂä®ÂèñÊ∂à\n"
                                        f"‚ñ´Ô∏è ‰∫§ÊòìÂØπ: {order_info['symbol']}\n"
                                        f"‚ñ´Ô∏è ËÆ¢ÂçïÁ±ªÂûã: {'Ê≠¢ÊçüÂçï' if order_info['type'] == 'STOP_LOSS' else 'Ê≠¢ÁõàÂçï'}\n"
                                        f"‚ñ´Ô∏è ËÆ¢ÂçïID: {order_id}\n"
                                        f"‚ñ´Ô∏è ÂéüÂßã‰ª∑Ê†º: {order_info.get('price', 'N/A')}"
                                    )
                                    await self._send_notification(msg)
                                
                                if new_status == old_status == 'NEW' and order_info.get('type') in ['STOP_LOSS', 'TAKE_PROFIT']:
                                    current_price = float(res['stopPrice'] if res.get('stopPrice') else res['price'])
                                    original_price = float(order_info.get('price', 0))
                                    
                                    if abs(current_price - original_price) > 0.00001:
                                        order_info['price'] = current_price
                                        await self._save_state()
                                        
                                        msg = (
                                            "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
                                            f"üìù ËÆ¢Âçï‰ª∑Ê†ºÂ∑≤Ë¢´ÊâãÂä®‰øÆÊîπ\n"
                                            f"‚ñ´Ô∏è ‰∫§ÊòìÂØπ: {order_info['symbol']}\n"
                                            f"‚ñ´Ô∏è ËÆ¢ÂçïÁ±ªÂûã: {'Ê≠¢ÊçüÂçï' if order_info['type'] == 'STOP_LOSS' else 'Ê≠¢ÁõàÂçï'}\n"
                                            f"‚ñ´Ô∏è ËÆ¢ÂçïID: {order_id}\n"
                                            f"‚ñ´Ô∏è ÂéüÂßã‰ª∑Ê†º: {original_price}\n"
                                            f"‚ñ´Ô∏è Êñ∞‰ª∑Ê†º: {current_price}"
                                        )
                                        await self._send_notification(msg)
                                
                                if new_status == 'FILLED':
                                    if order_info.get('type') == 'TAKE_PROFIT':
                                        msg = (
                                            "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
                                            f"‚úÖ Ê≠¢ÁõàËß¶Âèë {order_info['symbol']}\n"
                                            f"‚ñ´Ô∏è Ëß¶Âèë‰ª∑: {order_info['price']:.4f}\n"
                                            f"‚ñ´Ô∏è ËÆ¢ÂçïID: {order_id}"
                                        )
                                        await self._send_notification(msg)
                                    elif order_info.get('type') == 'STOP_LOSS':
                                        msg = (
                                            "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
                                            f"üõë Ê≠¢ÊçüËß¶Âèë {order_info['symbol']}\n"
                                            f"‚ñ´Ô∏è Ëß¶Âèë‰ª∑: {order_info['price']:.4f}\n"
                                            f"‚ñ´Ô∏è ËÆ¢ÂçïID: {order_id}"
                                        )
                                        await self._send_notification(msg)
                                
                                if new_status == 'FILLED' and old_status != 'FILLED':
                                    await self._on_order_filled(order_info)
                                
                                if new_status in ['FILLED', 'CANCELED']:
                                    self.active_orders.pop(order_id, None)
                                    await self._save_state()
                                    logger.info(f"Â∑≤Ê∏ÖÁêÜÁªìÊùüËÆ¢Âçï | ID: {order_id}")

                        except BinanceAPIException as e:
                            if e.code == -2013:
                                logger.info(f"‰∫§ÊòìÊâÄËÆ¢Âçï‰∏çÂ≠òÂú®ÔºåÊâßË°åÊ∏ÖÁêÜ | ID: {order_id}")
                                if order_info.get('type') in ['STOP_LOSS', 'TAKE_PROFIT']:
                                    msg = (
                                        "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
                                        "‚ö†Ô∏è Ê≠¢ÁõàÊ≠¢ÊçüËÆ¢ÂçïÂºÇÂ∏∏Ê∂àÂ§±\n"
                                        f"‚ñ´Ô∏è ‰∫§ÊòìÂØπ: {order_info['symbol']}\n"
                                        f"‚ñ´Ô∏è ËÆ¢ÂçïÁ±ªÂûã: {'Ê≠¢ÊçüÂçï' if order_info['type'] == 'STOP_LOSS' else 'Ê≠¢ÁõàÂçï'}\n"
                                        f"‚ñ´Ô∏è ËÆ¢ÂçïID: {order_id}\n"
                                        f"‚ñ´Ô∏è ÂéüÂßã‰ª∑Ê†º: {order_info.get('price', 'N/A')}"
                                    )
                                    await self._send_notification(msg)
                                self.active_orders.pop(order_id, None)
                                await self._save_state()
                            else:
                                logger.error(f"ËÆ¢ÂçïÊü•ËØ¢Â§±Ë¥• | ID: {order_id} | ÈîôËØØ: {e.message}")

                    symbols_to_check = set(o['symbol'] for o in self.active_orders.values())
                    for symbol in symbols_to_check:
                        positions = await self.client.futures_position_information(symbol=symbol)
                        position_exists = any(abs(float(pos['positionAmt'])) > 0 for pos in positions)

                        if not position_exists:
                            for o_id, o_info in list(self.active_orders.items()):
                                if o_info['symbol'] == symbol and o_info.get('type') in ['STOP_LOSS', 'TAKE_PROFIT']:
                                    try:
                                        await self.client.futures_cancel_order(
                                            symbol=symbol,
                                            orderId=o_id
                                        )
                                        msg = (
                                            "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
                                            f"üóë Âõ†Êó†ÊåÅ‰ªìÂèñÊ∂àÊåÇÂçï {symbol}\n"
                                            f"‚ñ´Ô∏è ËÆ¢ÂçïID: {o_id}\n"
                                            f"‚ñ´Ô∏è ËÆ¢ÂçïÁ±ªÂûã: {'Ê≠¢ÊçüÂçï' if o_info['type'] == 'STOP_LOSS' else 'Ê≠¢ÁõàÂçï'}"
                                        )
                                        await self._send_notification(msg)
                                        self.active_orders.pop(o_id)
                                    except BinanceAPIException as e:
                                        if e.code == -2011:
                                            self.active_orders.pop(o_id, None)
                            await self._save_state()

                    current_time = datetime.datetime.now(utc).timestamp()
                    if current_time - self.last_heartbeat >= HEARTBEAT_INTERVAL:
                        await update_heartbeat()
                        self.last_heartbeat = current_time

                    await asyncio.sleep(5)
                except asyncio.CancelledError:
                    logger.info("ËÆ¢ÂçïÁõëÊéß‰ªªÂä°Êî∂Âà∞ÂèñÊ∂à‰ø°Âè∑")
                    break
                except Exception as e:
                    logger.error(f"ËÆ¢ÂçïÁõëÊéßÂæ™ÁéØÂºÇÂ∏∏: {str(e)}", exc_info=True)
                    await asyncio.sleep(10)
        except asyncio.CancelledError:
            logger.info("ËÆ¢ÂçïÁõëÊéß‰ªªÂä°Ê≠£Â∏∏ÁªàÊ≠¢")
        except Exception as e:
            logger.error(f"ËÆ¢ÂçïÁõëÊéß‰ªªÂä°ÂºÇÂ∏∏ÈÄÄÂá∫: {str(e)}", exc_info=True)

    async def _check_signals(self):
        logger.info("ÂêØÂä®‰ø°Âè∑Êâ´ÊèèÂæ™ÁéØ")
        try:
            while not self._shutdown_event.is_set():
                try:
                    now = datetime.datetime.now(utc)
                    scan_flag = any([
                        (now.minute == 0) and now.second < 15,
                        (now.hour % 4 == 0) and now.minute == 0 and now.second < 15,
                        now.hour == 0 and now.minute == 0 and now.second < 15,
                        now.weekday() == 0 and now.hour == 0 and now.minute == 0 and now.second < 15
                    ])
                    
                    if scan_flag:
                        await asyncio.sleep(3)  # ÂÖ≥ÈîÆÂª∂Ëøü
                        logger.debug(f"‰ø°Âè∑Êâ´ÊèèËß¶ÂèëÔºåÂºÄÂßãÊâ´Êèè‰ø°Âè∑ | ÂΩìÂâçÊó∂Èó¥: {now}")
                        processed_count = 0
                        for symbol in CUSTOM_SYMBOLS:
                            for interval in INTERVALS:
                                klines = await self._get_klines(symbol, interval)
                                if klines and len(klines) >= 2:
                                    prev_kline = klines[0]  # Â∑≤Èó≠ÂêàÁöÑKÁ∫ø
                                    curr_kline = klines[1]  # ÂΩìÂâçÊú™Èó≠ÂêàÁöÑKÁ∫ø
                                    
                                    # Ê£ÄÊü•prev_klineÊòØÂê¶Â∑≤Èó≠Âêà
                                    kline_close_time = prev_kline[6] / 1000
                                    if datetime.datetime.now(utc).timestamp() < kline_close_time:
                                        continue
                                    
                                    kline_key = f"{symbol}|{interval}|{prev_kline[0]}"
                                    
                                    if kline_key in self.processed_klines:
                                        continue
                                        
                                    signal = self._analyze_kline(prev_kline, curr_kline, symbol)
                                    if signal:
                                        signal['interval'] = interval
                                        # Êñ∞Â¢ûÔºöÂèëÈÄÅ‰ø°Âè∑Ê£ÄÊµãÈÄöÁü•ÔºàÊó†ËÆ∫ÂèÇÊï∞ÊòØÂê¶ÊúâÊïàÔºâ
                                        signal_msg = (
                                            "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
                                            f"üîî Ê£ÄÊµãÂà∞ÊΩúÂú®‰ø°Âè∑ | {symbol} | {interval}\n"
                                            f"‚ñ´Ô∏è ÂΩ¢ÊÄÅ: Èî§Â≠êÁ∫ø/Êª°Ë∂≥Êù°‰ª∂\n"
                                            f"‚ñ´Ô∏è Âª∫ËÆÆÊñπÂêë: {signal['side']}\n"
                                            f"‚ñ´Ô∏è ÂéüÂßãÂèÇÊï∞: ÂÖ•Âú∫‰ª∑={signal['price']} | Ê≠¢Êçü={signal['stop_loss']} | Ê≠¢Áõà={signal['take_profit']}"
                                        )
                                        await self._send_notification(signal_msg)
                                        
                                        if kline_key not in self.processed_signals:
                                            logger.info(f"Ê£ÄÊµãÂà∞ÊúâÊïà‰ø°Âè∑ | {symbol} | {interval} | ‰ª∑Ê†º: {signal['price']}")
                                            await self._place_order(signal)
                                            self.processed_signals.add(kline_key)
                                            self.processed_klines[kline_key] = True
                                            await self._save_state()
                                            processed_count += 1
                                        else:
                                            logger.info(f"‰ø°Âè∑Â∑≤Â§ÑÁêÜ | {symbol} | {interval}")
                                    else:
                                        logger.debug(f"Êú™Ê£ÄÊµãÂà∞ÊúâÊïà‰ø°Âè∑ | {symbol} | {interval}")
                                        
                        logger.info(f"Êú¨ËΩÆÊâ´ÊèèËß¶Âèë‰ø°Âè∑Êï∞: {processed_count}")
                        await asyncio.sleep(60)
                    
                    current_time = datetime.datetime.now(utc).timestamp()
                    if current_time - self.last_heartbeat >= HEARTBEAT_INTERVAL:
                        await update_heartbeat()
                        self.last_heartbeat = current_time

                    await asyncio.sleep(1)
                except asyncio.CancelledError:
                    logger.info("‰ø°Âè∑Êâ´Êèè‰ªªÂä°Êî∂Âà∞ÂèñÊ∂à‰ø°Âè∑")
                    break
                except Exception as e:
                    logger.error(f"‰ø°Âè∑Êâ´ÊèèÂºÇÂ∏∏: {str(e)}", exc_info=True)
                    if not self._shutdown_event.is_set():
                        await asyncio.sleep(10)
        except asyncio.CancelledError:
            logger.info("‰ø°Âè∑Êâ´Êèè‰ªªÂä°Ê≠£Â∏∏ÁªàÊ≠¢")
        except Exception as e:
            logger.error(f"‰ø°Âè∑Êâ´Êèè‰ªªÂä°ÂºÇÂ∏∏ÈÄÄÂá∫: {str(e)}", exc_info=True)

    async def _check_tp_price_reached(self):
        logger.info("ÂêØÂä®Ê≠¢Áõà‰ª∑Ê†ºÊ£ÄÊü•Âæ™ÁéØ")
        try:
            while not self._shutdown_event.is_set():
                try:
                    for order_id, order_info in list(self.active_orders.items()):
                        if order_info.get('status') != 'NEW' or not order_info.get('take_profit'):
                            continue

                        current_price = await self._get_current_price(order_info['symbol'])
                        if not current_price:
                            continue

                        if (order_info.get('side') == 'BUY' and 
                            current_price >= float(order_info['take_profit'])):
                            try:
                                await self.client.futures_cancel_order(
                                    symbol=order_info['symbol'],
                                    orderId=order_id
                                )
                                
                                msg = (
                                    "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
                                    "‚ùå ÂèñÊ∂àÊú™Êàê‰∫§ËÆ¢Âçï - Â∑≤ËææÊ≠¢Áõà‰ª∑\n"
                                    f"‚ñ´Ô∏è ‰∫§ÊòìÂØπ: {order_info['symbol']}\n"
                                    f"‚ñ´Ô∏è ËÆ¢ÂçïID: {order_id}\n"
                                    f"‚ñ´Ô∏è ÂΩìÂâç‰ª∑Ê†º: {current_price}\n"
                                    f"‚ñ´Ô∏è Ê≠¢Áõà‰ª∑Ê†º: {order_info['take_profit']}"
                                )
                                await self._send_notification(msg)
                                
                                self.active_orders.pop(order_id, None)
                                await self._save_state()
                                
                                logger.info(
                                    "Â∑≤ÂèñÊ∂àÊú™Êàê‰∫§ËÆ¢Âçï | Â∑≤ËææÊ≠¢Áõà‰ª∑ | "
                                    f"{order_info['symbol']} | "
                                    f"ËÆ¢ÂçïID: {order_id} | "
                                    f"ÂΩìÂâç‰ª∑Ê†º: {current_price} | "
                                    f"Ê≠¢Áõà‰ª∑: {order_info['take_profit']}"
                                )
                            except BinanceAPIException as e:
                                if e.code != -2011:  # ÂøΩÁï•"Unknown order sent"ÈîôËØØ
                                    logger.error(f"ÂèñÊ∂àËÆ¢ÂçïÂ§±Ë¥• | {order_info['symbol']} | ËÆ¢ÂçïID: {order_id} | ÈîôËØØ: {e.message}")
                    
                    await asyncio.sleep(1)
                except asyncio.CancelledError:
                    logger.info("Ê≠¢Áõà‰ª∑Ê†ºÊ£ÄÊü•‰ªªÂä°Êî∂Âà∞ÂèñÊ∂à‰ø°Âè∑")
                    break
                except Exception as e:
                    logger.error(f"Ê£ÄÊü•Ê≠¢Áõà‰ª∑Ê†ºÊó∂ÂèëÁîüÈîôËØØ: {str(e)}", exc_info=True)
                    await asyncio.sleep(1)
        except asyncio.CancelledError:
            logger.info("Ê≠¢Áõà‰ª∑Ê†ºÊ£ÄÊü•‰ªªÂä°Ê≠£Â∏∏ÁªàÊ≠¢")
        except Exception as e:
            logger.error(f"Ê≠¢Áõà‰ª∑Ê†ºÊ£ÄÊü•‰ªªÂä°ÂºÇÂ∏∏ÈÄÄÂá∫: {str(e)}", exc_info=True)

    async def _on_order_filled(self, order: dict):
        required_keys = ['orderId', 'symbol', 'price', 'quantity']
        if not all(key in order for key in required_keys):
            logger.error(f"ËÆ¢ÂçïÊï∞ÊçÆ‰∏çÂÆåÊï¥ÔºåÁº∫Â§±ÂÖ≥ÈîÆÂ≠óÊÆµ: {order}")
            return

        try:
            order_id = order.get('orderId')
            if not order_id or order_id not in self.active_orders:
                logger.warning(f"Êó†ÊïàÁöÑËÆ¢ÂçïÊï∞ÊçÆ: {order}")
                return

            self.active_orders[order_id]['status'] = 'FILLED'
            positions = await self.client.futures_position_information(symbol=order['symbol'])
            has_position = False
            for position in positions:
                if abs(float(position['positionAmt'])) > 0:
                    has_position = True
                    break
            
            if not has_position:
                self.active_orders.pop(order_id, None)
                await self._save_state()
                return

            symbol_info = self.symbols_info.get(order['symbol'], {'price_precision': 2})
            price_precision = symbol_info['price_precision']
            stop_loss = self._round_to_precision(order['stop_loss'], price_precision)
            take_profit = self._round_to_precision(order['take_profit'], price_precision)
            
            stop_params = {
                'symbol': order['symbol'],
                'side': 'SELL',
                'type': 'STOP_MARKET',
                'stopPrice': str(stop_loss),
                'closePosition': 'true'
            }
            if self.is_hedge_mode:
                stop_params['positionSide'] = 'LONG'

            sl_res = None
            try:
                sl_res = await self.client.futures_create_order(**stop_params)
                logger.info(f"Ê≠¢ÊçüÂçïÂàõÂª∫ÊàêÂäü | ËÆ¢ÂçïID: {sl_res['orderId']}")
                self.active_orders[sl_res['orderId']] = {
                    'symbol': order['symbol'],
                    'type': 'STOP_LOSS',
                    'status': 'NEW',
                    'price': stop_loss,
                    'orderId': sl_res['orderId']
                }
            except BinanceAPIException as e:
                logger.error(f"Ê≠¢ÊçüÂçïÂàõÂª∫Â§±Ë¥• | {order['symbol']} | ÈîôËØØ: {e.message}")
                await self._send_notification(
                    "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
                    f"‚ùå {order['symbol']} Ê≠¢ÊçüÂçïÂàõÂª∫Â§±Ë¥•: {e.message}"
                )

            tp_params = {
                'symbol': order['symbol'],
                'side': 'SELL',
                'type': 'LIMIT',
                'price': str(take_profit),
                'quantity': str(order['quantity']),
                'timeInForce': 'GTC'
            }
            if self.is_hedge_mode:
                tp_params['positionSide'] = 'LONG'

            tp_res = None
            try:
                tp_res = await self.client.futures_create_order(**tp_params)
                logger.info(f"Ê≠¢ÁõàÂçïÂàõÂª∫ÊàêÂäü | ËÆ¢ÂçïID: {tp_res['orderId']}")
                self.active_orders[tp_res['orderId']] = {
                    'symbol': order['symbol'],
                    'type': 'TAKE_PROFIT',
                    'status': 'NEW',
                    'price': take_profit,
                    'orderId': tp_res['orderId']
                }
            except BinanceAPIException as e:
                logger.error(f"Ê≠¢ÁõàÂçïÂàõÂª∫Â§±Ë¥• | {order['symbol']} | ÈîôËØØ: {e.message}")
                await self._send_notification(
                    "ü§ñ SHEJIÁ≥ªÁªüÈÄöÁü•\n"
                    f"‚ùå {order['symbol']} Ê≠¢ÁõàÂçïÂàõÂª∫Â§±Ë¥•: {e.message}"
                )
            
            await self._save_state()
        except Exception as e:
            logger.error(f"ËÆ¢ÂçïÊàê‰∫§Â§ÑÁêÜÂ§±Ë¥• | {order.get('symbol', 'UNKNOWN')} | ÈîôËØØ: {str(e)}", exc_info=True)
            await self._send_error_alert(e, f"ËÆ¢ÂçïÊàê‰∫§Â§ÑÁêÜ {order.get('symbol', 'UNKNOWN')}")

    async def shutdown(self):
        logger.info("ÂºÄÂßãÂÖ≥Èó≠Á≥ªÁªü...")
        self._shutdown_event.set()
        
        try:
            await asyncio.sleep(2)  # Á≠âÂæÖ‰ªªÂä°ÂÆåÊàê
            await self._save_state()
            if self.client:
                await self.client.close_connection()
            logger.info("Á≥ªÁªüÂ∑≤ÂÆâÂÖ®ÂÖ≥Èó≠")
        except Exception as e:
            logger.error(f"ÂÖ≥Èó≠ËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØ: {str(e)}", exc_info=True)

    async def run(self):
        try:
            await self.initialize()
            logger.info("Á≥ªÁªüÂêØÂä®ÂÆåÊàê")
            
            tasks = [
                asyncio.create_task(self._monitor_orders()),
                asyncio.create_task(self._check_signals()),
                asyncio.create_task(self._check_tp_price_reached())
            ]
            
            await asyncio.gather(*tasks)
        except asyncio.CancelledError:
            logger.info("Á≥ªÁªüËøêË°åË¢´ÂèñÊ∂à")
        except Exception as e:
            logger.error(f"Á≥ªÁªüËøêË°åÊó∂ÈîôËØØ: {str(e)}", exc_info=True)
            await self._send_error_alert(e, "‰∏ªÂæ™ÁéØ")
        finally:
            await self.shutdown()

async def async_shutdown(loop, system):
    try:
        logger.info("ÂºÄÂßãÂºÇÊ≠•ÂÖ≥Èó≠ÊµÅÁ®ã")
        system.running = False
        system._shutdown_event.set()
        await asyncio.sleep(2)
        
        tasks = [t for t in asyncio.all_tasks(loop) if t is not asyncio.current_task()]
        for task in tasks:
            task.cancel()
        
        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)
        
        await system.shutdown()
        await loop.shutdown_asyncgens()
        logger.info("ÂºÇÊ≠•ÂÖ≥Èó≠ÊµÅÁ®ãÂÆåÊàê")
    except Exception as e:
        logger.error(f"ÂºÇÊ≠•ÂÖ≥Èó≠ËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØ: {str(e)}", exc_info=True)

def signal_handler(sig, loop, system):
    logger.info(f"Êé•Êî∂Âà∞‰ø°Âè∑ {signal.Signals(sig).name}({sig})")
    asyncio.create_task(async_shutdown(loop, system))

if __name__ == "__main__":
    try:
        logger.info("\n" + "="*60)
        logger.info("Sheji‰∫§ÊòìÁ≥ªÁªüÂêØÂä®")
        
        system = ShejiTradingSystem()
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        for sig in (signal.SIGINT, signal.SIGTERM):
            loop.add_signal_handler(
                sig,
                functools.partial(signal_handler, sig, loop, system)
            )
        
        loop.run_until_complete(system.run())
    except KeyboardInterrupt:
        logger.info("Êé•Êî∂Âà∞Áî®Êà∑‰∏≠Êñ≠‰ø°Âè∑")
    except Exception as e:
        logger.error(f"Á≥ªÁªüËøêË°åÊó∂ÂèëÁîüÈîôËØØ: {str(e)}", exc_info=True)
    finally:
        try:
            if loop.is_running():
                loop.run_until_complete(async_shutdown(loop, system))
            loop.close()
        except Exception as e:
            logger.error(f"ÊúÄÁªàÊ∏ÖÁêÜËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØ: {str(e)}", exc_info=True)
        finally:
            logger.info("Á≥ªÁªüÂÆåÂÖ®ÂÖ≥Èó≠")